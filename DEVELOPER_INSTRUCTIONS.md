# Developer Instructions: Step 3 Editor Improvements

## Overview
Two main features need to be implemented in the AI Studio Step 3 editor:
1. **Tab Navigation Arrows** - Left/right scroll arrows when tabs overflow
2. **AI Action Buttons** - Make Improve, Shorten, Expand buttons call the API

---

## Feature 1: Tab Navigation Arrows

### Problem
When an RFP has many sections (e.g., 8+ tabs), they overflow the container and users can't access tabs on the right side.

### Solution
Add left/right arrow buttons that scroll the tab container horizontally.

### Files to Modify

#### 1. HTML Template: `app/api/ai_tools.py` (Lines 180-186)

**Current:**
```html
<div class="editor-tabs">
  <!-- Tabs will be dynamically generated by JavaScript -->
  <div class="editor-tab-actions">
    <button class="tab-action" type="button" title="Fullscreen">&#9939;</button>
  </div>
</div>
```

**Change to:**
```html
<div class="editor-tabs-wrapper">
  <button class="tab-nav-arrow tab-nav-left" type="button" title="Scroll left" style="display:none;">&#8249;</button>
  <div class="editor-tabs">
    <!-- Tabs will be dynamically generated by JavaScript -->
  </div>
  <button class="tab-nav-arrow tab-nav-right" type="button" title="Scroll right" style="display:none;">&#8250;</button>
  <div class="editor-tab-actions">
    <button class="tab-action" type="button" title="Fullscreen">&#9939;</button>
  </div>
</div>
```

#### 2. CSS: `app/web/static/css/ai-studio.css` (after line 961)

Add these styles:

```css
/* Tab Navigation Arrows */
.ai-tools-page .editor-tabs-wrapper {
  display: flex;
  align-items: center;
  background: #f8fafb;
  border-bottom: 1px solid #e2e8f0;
  position: relative;
}

.ai-tools-page .editor-tabs {
  display: flex;
  align-items: center;
  overflow-x: auto;
  scroll-behavior: smooth;
  flex: 1;
  padding: 0 8px;
  /* Hide scrollbar but keep functionality */
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.ai-tools-page .editor-tabs::-webkit-scrollbar {
  display: none;
}

.ai-tools-page .tab-nav-arrow {
  flex-shrink: 0;
  width: 32px;
  height: 100%;
  min-height: 48px;
  background: linear-gradient(90deg, #f8fafb 70%, transparent);
  border: none;
  cursor: pointer;
  font-size: 20px;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: color 0.2s, background 0.2s;
  z-index: 2;
}

.ai-tools-page .tab-nav-arrow:hover {
  color: var(--brand-primary);
  background: linear-gradient(90deg, #e8f5e9 70%, transparent);
}

.ai-tools-page .tab-nav-arrow:disabled {
  opacity: 0.3;
  cursor: not-allowed;
}

.ai-tools-page .tab-nav-left {
  background: linear-gradient(270deg, transparent, #f8fafb 30%);
}

.ai-tools-page .tab-nav-right {
  background: linear-gradient(90deg, transparent, #f8fafb 30%);
}
```

Also **update** the existing `.editor-tabs` rule (line 922-928) - remove `padding` and `border-bottom` since they're now on the wrapper:

```css
.ai-tools-page .editor-tabs {
  display: flex;
  align-items: center;
  overflow-x: auto;
  scroll-behavior: smooth;
  flex: 1;
  padding: 0 8px;
  scrollbar-width: none;
  -ms-overflow-style: none;
}
```

#### 3. JavaScript: `app/web/static/js/ai-studio.js`

**Step A:** Add element references (around line 30, in the `els` object):

```javascript
tabNavLeft: document.querySelector(".tab-nav-left"),
tabNavRight: document.querySelector(".tab-nav-right"),
```

**Step B:** Add scroll functions (after `renderDocumentTabs()` around line 968):

```javascript
function updateTabNavArrows() {
  const tabsContainer = document.querySelector(".editor-tabs");
  const leftArrow = document.querySelector(".tab-nav-left");
  const rightArrow = document.querySelector(".tab-nav-right");

  if (!tabsContainer || !leftArrow || !rightArrow) return;

  const canScrollLeft = tabsContainer.scrollLeft > 0;
  const canScrollRight = tabsContainer.scrollLeft < (tabsContainer.scrollWidth - tabsContainer.clientWidth - 1);

  leftArrow.style.display = (tabsContainer.scrollWidth > tabsContainer.clientWidth) ? "flex" : "none";
  rightArrow.style.display = (tabsContainer.scrollWidth > tabsContainer.clientWidth) ? "flex" : "none";

  leftArrow.disabled = !canScrollLeft;
  rightArrow.disabled = !canScrollRight;
}

function scrollTabs(direction) {
  const tabsContainer = document.querySelector(".editor-tabs");
  if (!tabsContainer) return;

  const scrollAmount = 200; // pixels to scroll
  tabsContainer.scrollBy({
    left: direction === "left" ? -scrollAmount : scrollAmount,
    behavior: "smooth"
  });

  // Update arrows after scroll animation
  setTimeout(updateTabNavArrows, 300);
}
```

**Step C:** Add event listeners in `bindEvents()` (around line 1454):

```javascript
// Tab navigation arrows
const tabNavLeft = document.querySelector(".tab-nav-left");
const tabNavRight = document.querySelector(".tab-nav-right");
const tabsContainer = document.querySelector(".editor-tabs");

if (tabNavLeft) {
  tabNavLeft.addEventListener("click", () => scrollTabs("left"));
}
if (tabNavRight) {
  tabNavRight.addEventListener("click", () => scrollTabs("right"));
}
if (tabsContainer) {
  tabsContainer.addEventListener("scroll", updateTabNavArrows);
}
```

**Step D:** Call `updateTabNavArrows()` at the end of `renderDocumentTabs()` (line 968):

```javascript
// Add at end of renderDocumentTabs function:
setTimeout(updateTabNavArrows, 100);
```

---

## Feature 2: AI Action Buttons (Improve, Shorten, Expand)

### Problem
The buttons currently just show a loading animation and do nothing (`simulateAiAction`).

### Solution
Create a new API endpoint and call it from the frontend.

### Files to Modify

#### 1. Backend API: Create new endpoint in `app/api/opportunity_generate.py`

Add this new endpoint (after the existing `/generate` endpoint, around line 330):

```python
class RefineRequest(BaseModel):
    content: str
    action: str  # "improve", "shorten", or "expand"
    section_name: str | None = None


@router.post("/{opportunity_id}/refine")
async def refine_content(
    opportunity_id: str,
    payload: RefineRequest,
    request: Request,
    user=Depends(require_user_with_team),
):
    """Refine content using AI - improve, shorten, or expand."""
    await ensure_user_can_access_opportunity(user, opportunity_id)
    _check_rate_limit(user.id)

    action = payload.action.lower()
    if action not in ("improve", "shorten", "expand"):
        raise HTTPException(status_code=400, detail="Invalid action. Use: improve, shorten, or expand")

    content = _sanitize_text(payload.content, max_chars=15000)
    if not content.strip():
        raise HTTPException(status_code=400, detail="No content to refine")

    # Build prompt based on action
    prompts = {
        "improve": """Improve the following RFP response text. Make it more professional,
clear, and compelling while preserving the key information and meaning.
Keep the same approximate length. Return ONLY the improved text, no explanations.""",

        "shorten": """Shorten the following RFP response text by approximately 30-40%.
Remove redundancy and verbose language while keeping all essential information.
Maintain a professional tone. Return ONLY the shortened text, no explanations.""",

        "expand": """Expand the following RFP response text by approximately 30-50%.
Add more detail, examples, and supporting information while maintaining accuracy.
Keep a professional tone. Return ONLY the expanded text, no explanations.""",
    }

    system_prompt = prompts[action]
    user_prompt = f"Text to {action}:\n\n{content}"

    try:
        llm = get_llm_client()
        result = await llm.chat(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            temperature=0.3,
        )

        refined_text = result.strip()
        if not refined_text:
            raise HTTPException(status_code=500, detail="AI returned empty response")

        return {"refined_content": refined_text, "action": action}

    except Exception as exc:
        logging.error("Refine error: %s", exc)
        raise HTTPException(status_code=500, detail=str(exc))
```

Also add the import at the top of the file:
```python
from pydantic import BaseModel
```

#### 2. Frontend: `app/web/static/js/ai-studio.js`

**Replace** the `simulateAiAction` function (lines 1435-1444) with:

```javascript
async function performAiAction(btn, action) {
  if (!btn) return;

  const content = els.editableContent?.innerHTML || "";
  if (!content.trim()) {
    showMessage("No content to " + action, "error");
    return;
  }

  const original = btn.innerHTML;
  setButtonLoading(btn, action === "improve" ? "Improving..." : action === "shorten" ? "Shortening..." : "Expanding...");

  // Disable all AI action buttons during operation
  [els.improveBtn, els.shortenBtn, els.expandBtn].forEach(b => {
    if (b) b.disabled = true;
  });

  try {
    const res = await fetch(
      `/api/opportunities/${encodeURIComponent(state.opportunityId)}/refine`,
      {
        method: "POST",
        credentials: "include",
        headers: {
          "Content-Type": "application/json",
          "X-CSRF-Token": getCsrf(),
        },
        body: JSON.stringify({
          content: content,
          action: action,
          section_name: state.currentDoc || null,
        }),
      }
    );

    if (!res.ok) {
      const text = await res.text();
      throw new Error(text || `${action} failed`);
    }

    const data = await res.json();

    // Update the editor content
    if (els.editableContent && data.refined_content) {
      els.editableContent.innerHTML = data.refined_content;
      // Update state
      if (state.currentDoc) {
        state.documents[state.currentDoc] = data.refined_content;
      }
      // Update preview
      renderDocuments();
      // Trigger autosave
      scheduleSave();
    }

    showSaveIndicator(action.charAt(0).toUpperCase() + action.slice(1) + "d");

  } catch (err) {
    console.error(`${action} error:`, err);
    showMessage(err.message || `Failed to ${action}`, "error");
  } finally {
    setButtonLoading(btn, null);
    btn.innerHTML = original;
    // Re-enable buttons
    [els.improveBtn, els.shortenBtn, els.expandBtn].forEach(b => {
      if (b) b.disabled = false;
    });
  }
}
```

**Update** the button event listeners (lines 1446-1454):

```javascript
if (els.improveBtn) {
  els.improveBtn.addEventListener("click", () => performAiAction(els.improveBtn, "improve"));
}
if (els.shortenBtn) {
  els.shortenBtn.addEventListener("click", () => performAiAction(els.shortenBtn, "shorten"));
}
if (els.expandBtn) {
  els.expandBtn.addEventListener("click", () => performAiAction(els.expandBtn, "expand"));
}
```

---

## Feature 3: Save Button

The Save button (`#manualSaveInline`) already works! It's connected at line 1471-1473:

```javascript
if (els.manualSaveInline) {
  els.manualSaveInline.addEventListener("click", () => saveSession(true));
}
```

This calls `saveSession(true)` which saves to `/api/ai-sessions/save` and shows "Saved" indicator.

**No changes needed** for Save functionality.

---

## Testing Checklist

### Tab Navigation
- [ ] Verify arrows appear only when tabs overflow
- [ ] Left arrow disabled when scrolled to start
- [ ] Right arrow disabled when scrolled to end
- [ ] Clicking arrows scrolls smoothly
- [ ] Arrow visibility updates on window resize
- [ ] Works with 2 tabs (arrows hidden)
- [ ] Works with 10+ tabs (arrows visible)

### AI Actions
- [ ] Improve button calls API and updates content
- [ ] Shorten button reduces text length
- [ ] Expand button increases text length
- [ ] Loading state shows during API call
- [ ] Buttons disabled during operation
- [ ] Error messages display on failure
- [ ] Content autosaves after AI modification
- [ ] Preview updates after AI modification

### Save Button
- [ ] Manual save works and shows "Saved" indicator
- [ ] Session persists after page refresh

---

## File Summary

| File | Changes |
|------|---------|
| `app/api/ai_tools.py` | Add tab wrapper HTML with arrow buttons |
| `app/web/static/css/ai-studio.css` | Add arrow styles, update tabs for overflow |
| `app/web/static/js/ai-studio.js` | Add scroll functions, replace simulateAiAction |
| `app/api/opportunity_generate.py` | Add `/refine` endpoint for AI actions |

---

## Notes

- Rate limiting is already in place (6 req/min per user) - the refine endpoint reuses `_check_rate_limit()`
- The LLM client supports both OpenAI and local Ollama - no changes needed
- CSRF protection is already handled via `getCsrf()` helper
- Error handling follows existing patterns in the codebase
